import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-minimal-pie-chart/es/index.js
var import_react = __toESM(require_react());
function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
}
function valueBetween(value, min, max) {
  if (value > max) return max;
  if (value < min) return min;
  return value;
}
function extractPercentage(value, percentage) {
  return percentage / 100 * value;
}
function bisectorAngle(startAngle, lengthAngle) {
  return startAngle + lengthAngle / 2;
}
function shiftVectorAlongAngle(angle, distance) {
  var angleRadians = degreesToRadians(angle);
  return {
    dx: distance * Math.cos(angleRadians),
    dy: distance * Math.sin(angleRadians)
  };
}
function isNumber(value) {
  return typeof value === "number";
}
function functionProp(prop, payload) {
  return typeof prop === "function" ? (
    // @ts-expect-error: cannot find a way to type 2nd prop arg as anything-but-function
    prop(payload)
  ) : prop;
}
function sumValues(data) {
  var sum = 0;
  for (var i = 0; i < data.length; i++) {
    sum += data[i].value;
  }
  return sum;
}
function extendData(_ref) {
  var data = _ref.data, totalAngle = _ref.lengthAngle, totalValue = _ref.totalValue, paddingAngle = _ref.paddingAngle, chartStartAngle = _ref.startAngle;
  var total = totalValue || sumValues(data);
  var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);
  var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;
  var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);
  var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;
  var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;
  var lastSegmentEnd = 0;
  var extendedData = [];
  for (var i = 0; i < data.length; i++) {
    var dataEntry = data[i];
    var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;
    var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);
    var startAngle = lastSegmentEnd + chartStartAngle;
    lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;
    extendedData.push(Object.assign({
      percentage: valueInPercentage,
      startAngle,
      degrees
    }, dataEntry));
  }
  return extendedData;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}
var _excluded$1 = ["dataEntry", "dataIndex"];
function ReactMinimalPieChartLabel(_ref) {
  var renderLabel = _ref.renderLabel, labelProps = _ref.labelProps;
  var label = renderLabel(labelProps);
  if (typeof label === "string" || typeof label === "number") {
    labelProps.dataEntry;
    labelProps.dataIndex;
    var props = _objectWithoutPropertiesLoose(labelProps, _excluded$1);
    return import_react.default.createElement("text", Object.assign({
      dominantBaseline: "central"
    }, props), label);
  }
  if (import_react.default.isValidElement(label)) {
    return label;
  }
  return null;
}
function round(number) {
  var divisor = 1e14;
  return Math.round((number + Number.EPSILON) * divisor) / divisor;
}
function evaluateTextAnchorPosition(_ref) {
  var labelPosition = _ref.labelPosition, lineWidth = _ref.lineWidth, labelHorizontalShift = _ref.labelHorizontalShift;
  var dx = round(labelHorizontalShift);
  if (dx === 0) {
    return "middle";
  }
  if (labelPosition > 100) {
    return dx > 0 ? "start" : "end";
  }
  var innerRadius = 100 - lineWidth;
  if (labelPosition < innerRadius) {
    return dx > 0 ? "end" : "start";
  }
  return "middle";
}
function makeLabelRenderProps(data, props) {
  return data.map(function(dataEntry, index) {
    var _functionProp;
    var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;
    var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;
    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(dataEntry.startAngle, dataEntry.degrees), distanceFromCenter), dx = _shiftVectorAlongAngl.dx, dy = _shiftVectorAlongAngl.dy;
    var labelRenderProps = {
      x: props.center[0],
      y: props.center[1],
      dx,
      dy,
      textAnchor: evaluateTextAnchorPosition({
        labelPosition: props.labelPosition,
        lineWidth: props.lineWidth,
        labelHorizontalShift: dx
      }),
      dataEntry,
      dataIndex: index,
      style: functionProp(props.labelStyle, index)
    };
    return labelRenderProps;
  });
}
function renderLabels(data, props) {
  var label = props.label;
  if (label) {
    return makeLabelRenderProps(data, props).map(function(labelRenderProps, index) {
      return import_react.default.createElement(ReactMinimalPieChartLabel, {
        key: "label-" + (labelRenderProps.dataEntry.key || index),
        renderLabel: label,
        labelProps: labelRenderProps
      });
    });
  }
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var svgPartialCircle;
var hasRequiredSvgPartialCircle;
function requireSvgPartialCircle() {
  if (hasRequiredSvgPartialCircle) return svgPartialCircle;
  hasRequiredSvgPartialCircle = 1;
  var partialCircle2 = function partialCircle3(cx, cy, r, start, end) {
    var length = end - start;
    if (length === 0) return [];
    var fromX = r * Math.cos(start) + cx;
    var fromY = r * Math.sin(start) + cy;
    var toX = r * Math.cos(end) + cx;
    var toY = r * Math.sin(end) + cy;
    var large = Math.abs(length) <= Math.PI ? "0" : "1";
    var sweep = length < 0 ? "0" : "1";
    return [["M", fromX, fromY], ["A", r, r, 0, large, sweep, toX, toY]];
  };
  svgPartialCircle = partialCircle2;
  return svgPartialCircle;
}
var svgPartialCircleExports = requireSvgPartialCircle();
var partialCircle = getDefaultExportFromCjs(svgPartialCircleExports);
var _excluded = ["cx", "cy", "lengthAngle", "lineWidth", "radius", "shift", "reveal", "rounded", "startAngle", "title"];
function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {
  var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);
  return partialCircle(
    cx,
    cy,
    // center X and Y
    radius,
    degreesToRadians(startAngle),
    degreesToRadians(startAngle + patchedLengthAngle)
  ).map(function(command) {
    return command.join(" ");
  }).join(" ");
}
function ReactMinimalPieChartPath(_ref) {
  var cx = _ref.cx, cy = _ref.cy, lengthAngle = _ref.lengthAngle, lineWidth = _ref.lineWidth, radius = _ref.radius, _ref$shift = _ref.shift, shift = _ref$shift === void 0 ? 0 : _ref$shift, reveal = _ref.reveal, rounded = _ref.rounded, startAngle = _ref.startAngle, title = _ref.title, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var pathRadius = radius - lineWidth / 2;
  var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift), dx = _shiftVectorAlongAngl.dx, dy = _shiftVectorAlongAngl.dy;
  var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);
  var strokeDasharray;
  var strokeDashoffset;
  if (isNumber(reveal)) {
    var pathLength = degreesToRadians(pathRadius) * lengthAngle;
    strokeDasharray = Math.abs(pathLength);
    strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);
  }
  return import_react.default.createElement("path", Object.assign({
    d: pathCommands,
    fill: "none",
    strokeWidth: lineWidth,
    strokeDasharray,
    strokeDashoffset,
    strokeLinecap: rounded ? "round" : void 0
  }, props), title && import_react.default.createElement("title", null, title));
}
function combineSegmentTransitionsStyle(duration, easing, customStyle) {
  var transition = "stroke-dashoffset " + duration + "ms " + easing;
  if (customStyle && customStyle.transition) {
    transition = transition + "," + customStyle.transition;
  }
  return {
    transition
  };
}
function getRevealValue(_ref) {
  var reveal = _ref.reveal, animate = _ref.animate;
  if (animate && !isNumber(reveal)) {
    return 100;
  }
  return reveal;
}
function makeEventHandler(eventHandler, payload) {
  return eventHandler && function(e) {
    eventHandler(e, payload);
  };
}
function renderSegments(data, props, revealOverride) {
  var reveal = revealOverride != null ? revealOverride : getRevealValue(props);
  var radius = props.radius, _props$center = props.center, cx = _props$center[0], cy = _props$center[1];
  var lineWidth = extractPercentage(radius, props.lineWidth);
  var paths = data.map(function(dataEntry, index) {
    var segmentsStyle = functionProp(props.segmentsStyle, index);
    return import_react.default.createElement(ReactMinimalPieChartPath, {
      cx,
      cy,
      key: dataEntry.key || index,
      lengthAngle: dataEntry.degrees,
      lineWidth,
      radius,
      rounded: props.rounded,
      reveal,
      shift: functionProp(props.segmentsShift, index),
      startAngle: dataEntry.startAngle,
      title: dataEntry.title,
      style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),
      stroke: dataEntry.color,
      tabIndex: props.segmentsTabIndex,
      onBlur: makeEventHandler(props.onBlur, index),
      onClick: makeEventHandler(props.onClick, index),
      onFocus: makeEventHandler(props.onFocus, index),
      onKeyDown: makeEventHandler(props.onKeyDown, index),
      onMouseOver: makeEventHandler(props.onMouseOver, index),
      onMouseOut: makeEventHandler(props.onMouseOut, index)
    });
  });
  if (props.background) {
    paths.unshift(import_react.default.createElement(ReactMinimalPieChartPath, {
      cx,
      cy,
      key: "bg",
      lengthAngle: props.lengthAngle,
      lineWidth,
      radius,
      rounded: props.rounded,
      startAngle: props.startAngle,
      stroke: props.background
    }));
  }
  return paths;
}
var defaultProps = {
  animationDuration: 500,
  animationEasing: "ease-out",
  center: [50, 50],
  data: [],
  labelPosition: 50,
  lengthAngle: 360,
  lineWidth: 100,
  paddingAngle: 0,
  radius: 50,
  startAngle: 0,
  viewBoxSize: [100, 100]
};
function makePropsWithDefaults(props) {
  var result = Object.assign({}, defaultProps, props);
  var key;
  for (key in defaultProps) {
    if (props[key] === void 0) {
      result[key] = defaultProps[key];
    }
  }
  return result;
}
function ReactMinimalPieChart(originalProps) {
  var props = makePropsWithDefaults(originalProps);
  var _useState = (0, import_react.useState)(props.animate ? 0 : null), revealOverride = _useState[0], setRevealOverride = _useState[1];
  (0, import_react.useEffect)(function() {
    if (props.animate) {
      setRevealOverride(null);
    }
  }, []);
  var extendedData = extendData(props);
  return import_react.default.createElement("svg", {
    viewBox: "0 0 " + props.viewBoxSize[0] + " " + props.viewBoxSize[1],
    width: "100%",
    height: "100%",
    className: props.className,
    style: props.style
  }, renderSegments(extendedData, props, revealOverride), renderLabels(extendedData, props), props.children);
}
export {
  ReactMinimalPieChart as PieChart,
  defaultProps as pieChartDefaultProps
};
//# sourceMappingURL=react-minimal-pie-chart.js.map
