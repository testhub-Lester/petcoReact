import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS
} from "./chunk-G3PMV62Z.js";

// node_modules/react-to-print/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-to-print/lib/index.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t(require_react()) : "function" == typeof define && define.amd ? define("lib", ["react"], t) : "object" == typeof exports ? exports.lib = t(require_react()) : e.lib = t(e.react);
    }("undefined" != typeof self ? self : exports, function(e) {
      return function() {
        "use strict";
        var t = { 155: function(t2) {
          t2.exports = e;
        } }, o = {};
        function n(e2) {
          var r2 = o[e2];
          if (void 0 !== r2) return r2.exports;
          var s2 = o[e2] = { exports: {} };
          return t[e2](s2, s2.exports, n), s2.exports;
        }
        n.d = function(e2, t2) {
          for (var o2 in t2) n.o(t2, o2) && !n.o(e2, o2) && Object.defineProperty(e2, o2, { enumerable: true, get: t2[o2] });
        }, n.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, n.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var r = {};
        n.r(r), n.d(r, { useReactToPrint: function() {
          return f;
        } });
        var s = n(155);
        function i({ level: e2 = "error", messages: t2, suppressErrors: o2 = false }) {
          o2 || ("error" === e2 ? console.error(t2) : "warning" === e2 ? console.warn(t2) : "debug" === e2 && console.debug(t2));
        }
        function l(e2, t2) {
          if (t2 || !e2) {
            const e3 = document.getElementById("printWindow");
            e3 && document.body.removeChild(e3);
          }
        }
        function a(e2, t2) {
          const { documentTitle: o2, onAfterPrint: n2, onPrintError: r2, preserveAfterPrint: s2, print: a2, suppressErrors: c2 } = t2;
          setTimeout(() => {
            var t3, d2;
            if (e2.contentWindow) if (e2.contentWindow.focus(), a2) a2(e2).then(() => null == n2 ? void 0 : n2()).then(() => l(s2)).catch((e3) => {
              r2 ? r2("print", e3) : i({ messages: ["An error was thrown by the specified `print` function"], suppressErrors: c2 });
            });
            else {
              if (e2.contentWindow.print) {
                const n3 = null !== (d2 = null === (t3 = e2.contentDocument) || void 0 === t3 ? void 0 : t3.title) && void 0 !== d2 ? d2 : "", r3 = e2.ownerDocument.title;
                o2 && (e2.ownerDocument.title = o2, e2.contentDocument && (e2.contentDocument.title = o2)), e2.contentWindow.print(), o2 && (e2.ownerDocument.title = r3, e2.contentDocument && (e2.contentDocument.title = n3));
              } else i({ messages: ["Printing for this browser is not currently possible: the browser does not have a `print` method available for iframes."], suppressErrors: c2 });
              null == n2 || n2(), l(s2);
            }
            else i({ messages: ["Printing failed because the `contentWindow` of the print iframe did not load. This is possibly an error with `react-to-print`. Please file an issue: https://github.com/MatthewHerbst/react-to-print/issues/"], suppressErrors: c2 });
          }, 500);
        }
        function c(e2) {
          const t2 = [], o2 = document.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, null);
          let n2 = o2.nextNode();
          for (; n2; ) t2.push(n2), n2 = o2.nextNode();
          return t2;
        }
        function d(e2, t2, o2) {
          const n2 = c(e2), r2 = c(t2);
          if (n2.length === r2.length) for (let e3 = 0; e3 < n2.length; e3++) {
            const t3 = n2[e3], s2 = r2[e3], i2 = t3.shadowRoot;
            if (null !== i2) {
              const e4 = s2.attachShadow({ mode: i2.mode });
              e4.innerHTML = i2.innerHTML, d(i2, e4, o2);
            }
          }
          else i({ messages: ["When cloning shadow root content, source and target elements have different size. `onBeforePrint` likely resolved too early.", e2, t2], suppressErrors: o2 });
        }
        const u = '\n    @page {\n        /* Remove browser default header (title) and footer (url) */\n        margin: 0;\n    }\n    @media print {\n        body {\n            /* Tell browsers to print background colors */\n            color-adjust: exact; /* Firefox. This is an older version of "print-color-adjust" */\n            print-color-adjust: exact; /* Firefox/Safari */\n            -webkit-print-color-adjust: exact; /* Chrome/Safari/Edge/Opera */\n        }\n    }\n';
        function p(e2, t2, o2, n2) {
          var r2, s2, l2;
          const { contentNode: c2, clonedContentNode: p2, clonedImgNodes: h2, clonedVideoNodes: f2, numResourcesToLoad: g, originalCanvasNodes: m } = o2, { bodyClass: b, fonts: y, ignoreGlobalStyles: v, pageStyle: w, nonce: E, suppressErrors: A, copyShadowRoots: T } = n2;
          e2.onload = null;
          const x = e2.contentDocument || (null === (r2 = e2.contentWindow) || void 0 === r2 ? void 0 : r2.document);
          if (x) {
            const o3 = x.body.appendChild(p2);
            T && d(c2, o3, !!A), y && ((null === (s2 = e2.contentDocument) || void 0 === s2 ? void 0 : s2.fonts) && (null === (l2 = e2.contentWindow) || void 0 === l2 ? void 0 : l2.FontFace) ? y.forEach((o4) => {
              const n4 = new FontFace(o4.family, o4.source, { weight: o4.weight, style: o4.style });
              e2.contentDocument.fonts.add(n4), n4.loaded.then(() => {
                t2(n4);
              }).catch((e3) => {
                t2(n4, ["Failed loading the font:", n4, "Load error:", e3]);
              });
            }) : (y.forEach((e3) => t2(e3)), i({ messages: ['"react-to-print" is not able to load custom fonts because the browser does not support the FontFace API but will continue attempting to print the page'], suppressErrors: A })));
            const n3 = null != w ? w : u, r3 = x.createElement("style");
            E && (r3.setAttribute("nonce", E), x.head.setAttribute("nonce", E)), r3.appendChild(x.createTextNode(n3)), x.head.appendChild(r3), b && x.body.classList.add(...b.split(" "));
            const a2 = x.querySelectorAll("canvas");
            for (let e3 = 0; e3 < m.length; ++e3) {
              const t3 = m[e3], o4 = a2[e3];
              if (void 0 === o4) {
                i({ messages: ["A canvas element could not be copied for printing, has it loaded? `onBeforePrint` likely resolved too early.", t3], suppressErrors: A });
                continue;
              }
              const n4 = o4.getContext("2d");
              n4 && n4.drawImage(t3, 0, 0);
            }
            for (let e3 = 0; e3 < h2.length; e3++) {
              const o4 = h2[e3], n4 = o4.getAttribute("src");
              if (n4) {
                const e4 = new Image();
                e4.onload = () => t2(o4), e4.onerror = (e5, n5, r4, s3, i2) => t2(o4, ["Error loading <img>", o4, "Error", i2]), e4.src = n4;
              } else t2(o4, ['Found an <img> tag with an empty "src" attribute. This prevents pre-loading it.', o4]);
            }
            for (let e3 = 0; e3 < f2.length; e3++) {
              const o4 = f2[e3];
              o4.preload = "auto";
              const n4 = o4.getAttribute("poster");
              if (n4) {
                const e4 = new Image();
                e4.onload = () => t2(o4), e4.onerror = (e5, r4, s3, i2, l3) => t2(o4, ["Error loading video poster", n4, "for video", o4, "Error:", l3]), e4.src = n4;
              } else o4.readyState >= 2 ? t2(o4) : (o4.onloadeddata = () => t2(o4), o4.onerror = (e4, n5, r4, s3, i2) => t2(o4, ["Error loading video", o4, "Error", i2]), o4.onstalled = () => t2(o4, ["Loading video stalled, skipping", o4]));
            }
            const g2 = "select", S = c2.querySelectorAll(g2), k = x.querySelectorAll(g2);
            for (let e3 = 0; e3 < S.length; e3++) k[e3].value = S[e3].value;
            if (!v) {
              const e3 = document.querySelectorAll("style, link[rel~='stylesheet'], link[as='style']");
              for (let o4 = 0, n4 = e3.length; o4 < n4; ++o4) {
                const n5 = e3[o4];
                if ("style" === n5.tagName.toLowerCase()) {
                  const e4 = x.createElement(n5.tagName), t3 = n5.sheet;
                  if (t3) {
                    let r4 = "";
                    try {
                      const e5 = t3.cssRules.length;
                      for (let o5 = 0; o5 < e5; ++o5) "string" == typeof t3.cssRules[o5].cssText && (r4 += `${t3.cssRules[o5].cssText}\r
`);
                    } catch (e5) {
                      i({ messages: ["A stylesheet could not be accessed. This is likely due to the stylesheet having cross-origin imports, and many browsers block script access to cross-origin stylesheets. See https://github.com/MatthewHerbst/react-to-print/issues/429 for details. You may be able to load the sheet by both marking the stylesheet with the cross `crossorigin` attribute, and setting the `Access-Control-Allow-Origin` header on the server serving the stylesheet. Alternatively, host the stylesheet on your domain to avoid this issue entirely.", n5, `Original error: ${null == e5 ? void 0 : e5.message}`], level: "warning" });
                    }
                    e4.setAttribute("id", `react-to-print-${o4}`), E && e4.setAttribute("nonce", E), e4.appendChild(x.createTextNode(r4)), x.head.appendChild(e4);
                  }
                } else if (n5.getAttribute("href")) if (n5.hasAttribute("disabled")) i({ messages: ["`react-to-print` encountered a <link> tag with a `disabled` attribute and will ignore it. Note that the `disabled` attribute is deprecated, and some browsers ignore it. You should stop using it. https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-disabled. The <link> is:", n5], level: "warning" }), t2(n5);
                else {
                  const e4 = x.createElement(n5.tagName);
                  for (let t3 = 0, o5 = n5.attributes.length; t3 < o5; ++t3) {
                    const o6 = n5.attributes[t3];
                    o6 && e4.setAttribute(o6.nodeName, o6.nodeValue || "");
                  }
                  e4.onload = () => t2(e4), e4.onerror = (o5, n6, r4, s3, i2) => t2(e4, ["Failed to load", e4, "Error:", i2]), E && e4.setAttribute("nonce", E), x.head.appendChild(e4);
                }
                else i({ messages: ["`react-to-print` encountered a <link> tag with an empty `href` attribute. In addition to being invalid HTML, this can cause problems in many browsers, and so the <link> was not loaded. The <link> is:", n5], level: "warning" }), t2(n5);
              }
            }
          }
          0 === g && a(e2, n2);
        }
        function h(e2, t2, o2, n2) {
          e2.onload = () => p(e2, t2, o2, n2), document.body.appendChild(e2);
        }
        function f(e2) {
          const { contentRef: t2, fonts: o2, ignoreGlobalStyles: n2, onBeforePrint: r2, onPrintError: c2, preserveAfterPrint: d2, suppressErrors: u2 } = e2, p2 = (0, s.useCallback)((s2) => {
            l(d2, true);
            const p3 = function({ contentRef: e3, optionalContent: t3, suppressErrors: o3 }) {
              return t3 && (e3 && i({ level: "warning", messages: ['"react-to-print" received a `contentRef` option and a optional-content param passed to its callback. The `contentRef` option will be ignored.'] }), "function" == typeof t3) ? t3() : e3 ? e3.current : void i({ messages: ['"react-to-print" did not receive a `contentRef` option or a optional-content param pass to its callback.'], suppressErrors: o3 });
            }({ contentRef: t2, optionalContent: s2, suppressErrors: u2 });
            if (!p3) return void i({ messages: ["There is nothing to print"], suppressErrors: u2 });
            const f2 = p3.cloneNode(true), g = document.querySelectorAll("link[rel~='stylesheet'], link[as='style']"), m = f2.querySelectorAll("img"), b = f2.querySelectorAll("video"), y = o2 ? o2.length : 0, v = (n2 ? 0 : g.length) + m.length + b.length + y, w = [], E = [], A = function() {
              const e3 = document.createElement("iframe");
              return e3.width = `${document.documentElement.clientWidth}px`, e3.height = `${document.documentElement.clientHeight}px`, e3.style.position = "absolute", e3.style.top = `-${document.documentElement.clientHeight + 100}px`, e3.style.left = `-${document.documentElement.clientWidth + 100}px`, e3.id = "printWindow", e3.srcdoc = "<!DOCTYPE html>", e3;
            }(), T = (t3, o3) => {
              w.includes(t3) ? i({ level: "debug", messages: ["Tried to mark a resource that has already been handled", t3], suppressErrors: u2 }) : (o3 ? (i({ messages: ['"react-to-print" was unable to load a resource but will continue attempting to print the page', ...o3], suppressErrors: u2 }), E.push(t3)) : w.push(t3), w.length + E.length === v && a(A, e2));
            }, x = { contentNode: p3, clonedContentNode: f2, clonedImgNodes: m, clonedVideoNodes: b, numResourcesToLoad: v, originalCanvasNodes: p3.querySelectorAll("canvas") };
            r2 ? r2().then(() => h(A, T, x, e2)).catch((e3) => {
              null == c2 || c2("onBeforePrint", e3);
            }) : h(A, T, x, e2);
          }, [e2]);
          return p2;
        }
        return r;
      }();
    });
  }
});
export default require_lib();
//# sourceMappingURL=react-to-print.js.map
